** 프로젝트 파일들 설명

app 폴더(root segment) : 내가 코드 짤 폴더 

page.js : 메인페이지 (정상적으로 로딩이 되었을 때 나오는 페이지)

layout.js : 메인페이지를 감싸는 용도의 페이지 

public 폴더 : 이미지나 static 파일 보관용 

api 폴더 : 서버기능 만드는 곳 

 

next.config.js : nextJS 설정 파일 

node_modules 폴더 : 설치한 라이브러리 보관용 폴더 

package.json : 설치한 라이브러리 버전 기록용 파일

===========================================

.env.local 같은 환경변수는 클라이언트 컴포넌트에 정보가 노출이 되면 안되기 때문에
환경변수는 layout.js와 같은 서버 컴포넌트에서 접속이 가능함

* But 만약 웹브라우저를 위한 환경변수를 사용하고 싶다면??
-> 'NEXT_PUBLIC_' 를 접두사로 붙이면 됨 

===========================================

* 동적 라우팅 (Dynamic Routing)이란?

- 항상 미리 정의된 경로를 사용할 수 있는 것은 아니다.
예를 들어, 게시물의 경로는 /page/1, /page/2 … 처럼 되어있는데, 
모든 경로에 대해 미리 정의하거나 페이지 컴포넌트를 생성하는 일은 굉장히 비효율적이고, 정확하지 않을 수 있다.

이때 사용하는 것이 동적 라우팅이다!!
페이지 파일을 생성할때 대괄호[]를 추가하면 해당 페이지 컴포넌트는 동적으로 라우팅된다.

ex)
type Props = {
  params: {
    location: string;
  };
};

export default function Detail({ params }: Props) {
  return (
    <>
      <h1>Detail {params.location}</h1>
    </>
  );
}
~~> 이런식으로 해주면 라우팅이 동적으로 바뀌어 url(location)이 바뀌면 페이지에 h1글씨도 자동으로 바뀜 

===========================================

* server? client? (컴포넌트)

==> ! 클라이언트 컴포넌트에 ->  서버 컴포넌트를 import할 수 없다!!! (그대신 클라이언트 컴포넌트에서 ~> 서버 컴포넌트를 사용하고 싶을 땐 props로 넘겨주면 된다.)

ex) 
'use client'

import { useState } from 'react'

export default function ClientComponent({ children }:{children: React.ReactNode}){
  // 서버 컴포넌트를 자식 요소로 전달할 수 있다.
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={()=>{setCount(count + 1)}}>{count}</button>
      {children}
    </>
  )
}

---------------------------------------------------------------------

** client component
- 이벤트가 들어가는 행위(onClick, on... 등등) 자체는 서버 컴포넌트가 용납할 수 없는 동작이다.
그렇기 때문에 이벤트가 들어가는 컴포넌트는 클라이언트 컴포넌트가 되어야 한다!!  (컴포넌트 최상단에 'use client' 라고 명시해주면 됨)

- 클라이언트 컴포넌트는 최대한 말단으로 보내야 하기 때문에 -> 클라이언트 컴포넌트인 경우 별도의 컴포넌트로 빼주면 나중에 말단으로 빼기 쉬워진다. 

---------------------------------------------------------------------

** server component
- 서버 컴포넌트에선 hook, event를 사용할 수 없다. Hook과 EventListener와 같은 방식을 이용하려면 -> 클라이언트 컴포넌트를 사용할 것!
하지만 우린 useState와 같은 hook을 많이 사용하는데 서버 컴포넌트를 쓸 일이 있나? 라는 의문점을 가질수 있는데,
=> 그래서 Next13버전에서는 클라이언트 컴포넌트를 최대한 트리의 끝으로(말단으로) 보내라는 말을 한다. (즉, 'use client'가 최대한 트리 구조 끝으로 가야한다는걸 의미 )
! 그래서 아직은 클라이언트 컴포넌트를 많이 사용한다고 한다. 

===========================================

* 에러 컴포넌트
- 에러 컴포넌트는 반드시 클라이언트 컴포넌트여야 한다! => 에러 컴포넌트에 'use client' 추가 해줌

===========================================
* 캐시

캐시를 풀기 위해선 'revalidateTag'라는 함수를 이용해야 한다.
-> revalidateTag라는 함수는 서버에서만 동작을 수행할 수 있다. (revalidate 컴포넌트 참조)

===========================================

* 라우팅

- NextJS에서는 경로 지정하는 방식을 파일 시스템 기반으로 한다. (그걸 app이라는 디렉토리 아래에 정의를 하면 됨 => 이런 방식을 'App Router' 라고 함)
그렇기 때문에 '폴더의 이름을 따라서 URL Path를 정의할 수 있다!' 
- app 이라는 디렉토리 안에 어떠한 폴더를 정의하고 ->  그 안에 규칙에 맞는 파일들을 정의하면 -> 그것이 URL Path와 일치하는 형태로 사용될 수 있다는걸 의미함 

ex) 
app/dashboard/page.tsx 

-> 여기서 dashboard라고 정의한것이 디렉토리고 폴더다. (즉, dashboard라는 폴더가 경로의 이름으로 사용될 수 있다는걸 의미함)
! Next.js에서는 이렇게 경로의 이름이 되는 폴더(이름으로 사용되는 폴더)를 segment라고 부른다. => 대시보드 segment라고 부르면 됨.

* 'app은 가장 기초가 되는 segment다' 라고 해서 => 'root segment'라고 부른다!   

---------------------------------------------------------------------
- 또한 상황에 따라 파일 이름을 달리 지어줄 수 있는데, segment안에는 파일이 필요하다. 
위 예시처럼 dashboard segment안에 page.tsx를 만들어 주었는데, 이 파일은 성공적으로 이 페이지가 렌더링 됐을 때 보여질 UI를 그려준다. 
- 다양한 상황이 있는데, 흔히 에러가 발생할 수도 있고 로딩이 필요할 수도 있다. 또한 전반적인 레이아웃을 그려야 할 수도 있는데, 
  ! 이걸 위해 필요한 파일 이름이 정의되어 있다!! 
    => 특히 error.tsx인데,이 경우 error라는 파일 안에 에러 상황에 그려주고 싶은 UI를 정의하기만 하면 error 상황에 이 페이지를 보여주게 된다.
    => 또한, loading.tsx 라는 loading이라는 페이지를 만들면 -> 페이지 내 필요한 로딩이 발생할 때 이 loading이라는 페이지를 보여준다. (데이터가 받아오는 속도가 느리거나 할 경우!)
